.\" Automatically generated by Pandoc 1.17.0.3
.\"
.TH "uncov" "1" "January 07, 2017" "" ""
.hy
.SH NAME
.PP
uncov is a software development tool that collect and processes coverage
reports.
.SH SYNOPSIS
.PP
\f[B]uncov\f[] [<repo\-path>] <subcommand> [subcommand args...]
.SH DESCRIPTION
.PP
\f[C]uncov\f[] operates a number of entities, which are directly linked
to subcommands and information they output.
Below you can find their description.
.SS Repository
.PP
Repository is used as a source of file contents and its root directory
(not worktree one) is used to store data of \f[C]uncov\f[] itself.
While the relation by default is of one\-to\-one kind, same
\f[C]uncov\f[] data can be shared by multiple copies of the same
repository by linking or copying \f[C]uncov.sqlite\f[] file manually.
.PP
Repository that corresponds to current working directory is discovered
automatically and doesn\[aq]t need to be specified explicitly.
Otherwise \f[B]<repo\-path>\f[] can point either to repository directory
(\f[C]\&.git\f[]) or its main worktree (doesn\[aq]t seem to work with
secondary worktrees).
.SS Builds
.PP
The largest entity \f[C]uncov\f[] operates within repository is a build.
A build has the following properties:
.IP \[bu] 2
number identifying the build (greater than \f[C]0\f[]);
.IP \[bu] 2
name of reference within repository (branch usually);
.IP \[bu] 2
commit object that corresponds to the build;
.IP \[bu] 2
date and time at which it was imported;
.IP \[bu] 2
finally, set of files with their coverage that constitute a build.
.SS Files
.PP
File is the second most important thing after a build.
It\[aq]s characterised by:
.IP \[bu] 2
path within repository;
.IP \[bu] 2
coverage information (basically an array specifying which lines are
covered);
.IP \[bu] 2
MD5 hash (to verify that \f[C]uncov\f[] state is consistent with
repository).
.SS Directories
.PP
As we have set of files with their paths, we can derive interesting part
of file\-system structure of repository (ignoring the rest of it, where
there are no source files).
Directory is just a sum of information of all files it contains.
.SS Build relation
.PP
In order to be able to calculate change of coverage an ordering of
builds is imposed, which currently simply assumes that for build number
\f[C]N\f[] there is a \f[I]previous build\f[] with number
\f[C]N\ \-\ 1\f[] (when \f[C]N\ >\ 0\f[], build number \f[C]0\f[] has no
previous build).
.SS Statistics
.PP
File coverage information is the sole source of statistics.
Based on data provided any line of code is classified as either
\f[I]relevant\f[] or \f[I]not relevant\f[].
Relevant lines in turn can be \f[I]covered\f[] or \f[I]missed\f[].
So each source line must be in one of three states:
.IP \[bu] 2
not relevant;
.IP \[bu] 2
not covered (with number of hits being \f[C]0\f[]);
.IP \[bu] 2
covered (with number of hits being greater than \f[C]0\f[]).
.PP
Coverage rate is defined simply as number of covered lines divided by
number of relevant lines.
If file consists solely of not relevant lines (which is also the case
for files that don\[aq]t exist in one of builds being compared),
it\[aq]s assumed to have 100% coverage.
We also have number of lines covered, missed and total number of
relevant lines (sum of previous two) and can calculate their changes.
.PP
It is these statistics that are displayed by subcommands alongside
builds, directories and files.
Data describing changes is calculated from state of files in two builds:
some build and build that is considered to be its predecessor.
.SS Comparison
.PP
Comparison accounts for hierarchy: build comparison compares all their
files, directory comparison compares files under specified path, file
comparison compares only one file.
.PP
However, comparing coverage is not exactly the same as comparing files.
While we are interested in whether changed code is covered we don\[aq]t
really care about addition or removal of lines that aren\[aq]t relevant
for coverage.
So these uninteresting changes are not shown.
.PP
On the other hand, change of coverage when only number of line hits
increased or decreased is also irrelevant in most cases and are shown
only by separate command.
Regular comparison draws attention mainly to lines that have changed
their state (e.g., from "not covered" to "covered" or vice versa).
Should such lines be part of diff context, they are displayed as
somewhat dimmed compared to lines with interesting changes.
.SS Notations
.PP
For the sake of brevity interface uses several intuitive abbreviations:
.IP \[bu] 2
Cov \- coverage;
.IP \[bu] 2
Ref \- reference (of VCS);
.IP \[bu] 2
C \- covered;
.IP \[bu] 2
M \- missed;
.IP \[bu] 2
R \- relevant.
.SH SUBCOMMANDS
.SS Syntax of build numbers
.PP
Build numbers are specified in arguments for subcommands by being
prepended with \f[C]\@\f[] sign.
So to refer to build number \f[C]5\f[], one would write \f[C]\@5\f[].
.PP
Build numbers start at \f[C]1\f[], this leaves \f[C]\@0\f[] unused.
It is thus repurposed to be a handy shortcut for the latest build.
An alternative form of writing \f[C]\@0\f[] is \f[C]\@\@\f[].
.SS Resolving ambiguity
.PP
Some commands can take optional build number, which opens the door for
ambiguity between file/directory names and build identifiers.
Anything that starts with \f[C]\@\f[] at a suitable position on
command\-line is assumed to be build number.
For files which have \f[C]\@\f[] as prefix, specifying build number
becomes mandatory.
As an example:
.IP
.nf
\f[C]
#\ this\ doesn\[aq]t\ work
uncov\ show\ \@strangely\-named\-file
#\ this\ is\ equivalent\ and\ works
uncov\ show\ \@\@\ \@strangely\-named\-file
\f[]
.fi
.SS Default build
.PP
If a subcommand accepts build number, in almost all cases it\[aq]s an
optional parameter and latest build is used when this argument is
omitted.
.SS Subcommand aliases
.PP
Instead of requiring arguments for subcommands a different approach has
been taken.
Some commands have several names and depending on how you call them,
they act slightly differently.
.SS Paths
.PP
As a convenience when current working directory is under work tree of a
repository, paths that do not start with a slash \f[C]/\f[] are
automatically converted to be relative to root of the repository.
.SH LIST OF SUBCOMMANDS
.SS build
.PP
Displays information about one build.
.PP
\f[B]Usage: build\f[]
.PP
Describes the last build.
.PP
\f[B]Usage: build <build>\f[]
.PP
Describes \f[B]<build>\f[].
.SS builds
.PP
Lists builds.
.PP
\f[B]Usage: builds\f[]
.PP
Lists at most 10 most recent builds.
.PP
\f[B]Usage: builds <max list length>\f[]
.PP
Lists at most \f[B]<max list length>\f[] most recent builds.
.PP
\f[B]Usage: builds all\f[]
.PP
Lists all builds.
.SS changed
.PP
Same as \f[B]files\f[] subcommand, but omits listing files which have
their coverage rate unchanged.
.PP
See description of \f[B]files\f[] subcommand below for syntax.
.SS diff
.PP
Compares builds, directories or files.
Lines of files are compared by their state (i.e., changes in number of
hits when both old and new values are bigger than \f[C]0\f[] are treated
as no change).
.PP
\f[B]Usage: diff\f[]
.PP
Compares the last build with its predecessor.
.PP
\f[B]Usage: diff <old build>\f[]
.PP
Compares the last build with \f[B]<old build>\f[].
.PP
\f[B]Usage: diff <old build> <new build>\f[]
.PP
Compares \f[B]<new build>\f[] with \f[B]<old build>\f[].
.PP
\f[B]Usage: diff [<old build>] [<new build>] <path>\f[]
.PP
See forms above for information about first two arguments.
If \f[B]<path>\f[] specifies directory in either of two builds, only
files under it and below are compared.
If \f[B]<path>\f[] specifies file, only that file is compared.
.SS diff\-hits
.PP
Same as \f[B]diff\f[] subcommand, but considers change of number of hits
of a line to be significant change.
.PP
See description of \f[B]diff\f[] subcommand above for syntax.
.SS dirs
.PP
Lists statistics of files grouped by directories they\[aq]re located in.
.PP
\f[B]Usage: dirs\f[]
.PP
Lists all directories of the last build.
.PP
\f[B]Usage: dirs <build>\f[]
.PP
Lists all directories of \f[B]<build>\f[] comparing them against
directories in its predecessor.
.PP
\f[B]Usage: dirs <old build> <new build>\f[]
.PP
Lists all directories of \f[B]<new build>\f[] comparing them against
directories in \f[B]<old build>\f[].
.PP
\f[B]Usage: dirs [<build>] <directory path>\f[]
.PP
Lists directories of \f[B]<build>\f[] (or last build) located under
\f[B]<directory path>\f[].
.PP
\f[B]Usage: dirs [<old build>] [<new build>] <directory path>\f[]
.PP
See forms above for information about first two arguments.
Lists directories located under \f[B]<directory path>\f[].
.SS files
.PP
Lists statistics of files.
.PP
\f[B]Usage: files\f[]
.PP
Lists all files of the last build.
.PP
\f[B]Usage: files <build>\f[]
.PP
Lists all files of \f[B]<build>\f[] comparing them against files in its
predecessor.
.PP
\f[B]Usage: files <old build> <new build>\f[]
.PP
Lists all files of \f[B]<new build>\f[] comparing them against files in
\f[B]<old build>\f[].
.PP
\f[B]Usage: files [<build>] <directory path>\f[]
.PP
Lists files of \f[B]<build>\f[] (or last build) located under
\f[B]<directory path>\f[].
.PP
\f[B]Usage: files [<old build>] [<new build>] <path>\f[]
.PP
See forms above for information about first two arguments.
Lists files located under \f[B]<path>\f[] (if it\[aq]s a directory) or
one file that exactly matches the path.
.SS get
.PP
Dumps coverage information of a file.
.PP
\f[B]Usage: get <build> <file path>\f[]
.PP
Prints information about the file in this form:
.IP
.nf
\f[C]
<commit>
<line1\ coverage\ as\ integer>
<line2\ coverage\ as\ integer>
<line3\ coverage\ as\ integer>
\&...
\f[]
.fi
.PP
See description of \f[B]new\f[] subcommand below for meaning of integer
values.
.SS missed
.PP
Same as \f[B]show\f[] subcommand, but folds not relevant and covered
lines and thus displays only parts of files that lack coverage.
.PP
See description of \f[B]show\f[] subcommand below for syntax.
.SS new
.PP
Imports new build from standard input.
.PP
\f[B]Usage: new\f[]
.PP
Reads coverage information from standard input in the following format:
.IP
.nf
\f[C]
<commit>
<ref\ name>
<file\ name\ relative\ to\ repository\ root>
<MD5\ hash\ of\ file\ contents>
<number\ of\ lines\ of\ coverage>
<line1\ coverage\ as\ integer>\ <line2\ coverage\ as\ integer>\ ...
<all\ other\ files\ in\ the\ same\ format>
\f[]
.fi
.PP
Integers have the following meaning:
.IP \[bu] 2
when less than zero (specifically \f[C]\-1\f[]) \-\- line is not
relevant;
.IP \[bu] 2
when equal to zero \-\- line is not covered (missed);
.IP \[bu] 2
when greater than zero \-\- line is covered and was hit that many times.
.SS new\-json
.PP
Imports new build in JSON format from standard input.
.PP
\f[B]Usage: new\-json\f[]
.PP
Reads coverage information from standard input in the following format:
.IP
.nf
\f[C]
<prefix\ that\ doesn\[aq]t\ contain\ {\ character>
{
\ \ \ \ "source_files":\ [
\ \ \ \ \ \ \ \ {
\ \ \ \ \ \ \ \ \ \ \ \ "source_digest":\ "<MD5\ hash>",
\ \ \ \ \ \ \ \ \ \ \ \ "source":\ "<source,\ which\ can\ be\ used\ instead\ of\ source_digest>",
\ \ \ \ \ \ \ \ \ \ \ \ "name":\ "file\ name\ relative\ to\ repository\ root",
\ \ \ \ \ \ \ \ \ \ \ \ "coverage":\ [null\ for\ not\ relevant\ lines,\ int\ for\ number\ of\ hits]
\ \ \ \ \ \ \ \ }
\ \ \ \ \ \ \ \ ...
\ \ \ \ ],
\ \ \ \ "git":\ {
\ \ \ \ \ \ \ \ "head":\ {
\ \ \ \ \ \ \ \ \ \ \ \ "id":\ "<commit>"
\ \ \ \ \ \ \ \ },
\ \ \ \ \ \ \ \ "branch":\ "<branch>"
\ \ \ \ }
}
\f[]
.fi
.PP
Any other elements are ignored.
.SS show
.PP
Prints whole build, files under directory or a single file with coverage
information.
.PP
\f[B]Usage: show\f[]
.PP
Prints all files of the last build.
.PP
\f[B]Usage: show <build>\f[]
.PP
Prints all files of \f[B]<build>\f[].
.PP
\f[B]Usage: show <build> <path>\f[]
.PP
Prints files of \f[B]<build>\f[] (or last build) located under
\f[B]<path>\f[] if it specifies directory or one specific file.
.SH FILES
.PP
\f[B]<repository\-directory>/uncov.sqlite\f[] \-\- storage of coverage
data.
.SH AUTHORS
xaizek <xaizek@openmailbox.org>.
